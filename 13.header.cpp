//#include "Header.h"
//함수 복습

//함수의 기본 형태
//반환타입 함수명()
//{
//	함수 호출 시 실행할 명령문
//}

//1. reuturn 값이 존재하는 함수
//반환타입 함수명()
//{
	//	return 반환 타입에 맞는 값;
//}
//ex) 반환 타입이 int라면 return 값도 int 형태의 값

//2. return 값이 존재하지 않는 함수(void)
//void 함수명
//{
//	함수 호출 시 실행할 명령문
//}

//함수 호출 방법
//함수명();

//return의 기능
//1. 함수를 종료하고, 함수를 호출한 위치로 이동시킵니다. (return이 없는 경우라면 함수의 명령이 끝나면 자동으로 종료)
//2. return 다음에 값이 작성된다면, 함수를 호출한 위치에해당 값을 전달합니다.
//3. C/C++의 return 값은 1개만 전달이 가능합니다.

//함수의 인수, 매개변수
//1. 인수, 인자 값(Argument) : 함수 호출 시 넣어줄 값

//2. 매개변수(parameter) : 함수의 도입부 () 부분에 작성될 함수 호출 시 전달받을 데이터에 대한 표현
//사용 예시)
//int sum(int a, int b);	<- 정수형 데이터 2개를 요구하는 함수 sum
//int func(void);	<- 매개변수에 void 가 적혀있다면, 매개변수가 필요 없음을 명시합니다.

//변수의 범위(Scope)
//1. 전역 변수(Global) : 함수 위부에서 선언된 변수
//						 1. 프로그램 내에 어떤 함수에서도 사용이 가능합니다.
//						 2. 프로그램 실행 중에 메모리 상에 계속 존재합니다.
//						 3. 특정 함수가 저역 변수의 값을 수정할 경우, 다른 함수에서 출력할 때 수정된 값이 나오게 됩니다.
//						 4. 별도로 초기롸를 안할 경우 숫자일 경우는 0, 데이터를 초기 값으로 자동 설정됩니다.(정수형 데이터의 0)
//2. 지역 변수(Local) : 함수 내부에서 선언된 변수
//						1. 변수가 선언된 함수 내에서만 사용이 가능합니다.(함수가 조욜되면 해당 데이터는 삭제됩니다.)
//						2. 지역 변수는 함수의 호출 시 생성되며 종료시 삭제됩니다.
//						3. 함수의 매개변수 또한, 일종의 지역 변수이빈다.(함수 호출 시 값을 받고, 변수로 사용되면 종료 시 삭제되기 때문)
//3. 정적 변수(Static) : 프로그램이 종료되기 전까지 소멸하지 않는 경우
//						 1. static 키워드가 붙은 변수를 의미합니다. ex) static int count;
//						 2. 정적 변수의 초기화는 1번만 진행합니다.
//						 3. 초기화하는 값은 반드시 상수여야 합니다.
//						 4. 함수 내에서 만들어도, 해당 변수는 사라지지 않고 유지됩니다.
//						 5. 함수의 매개 변수로 사용할 수 없습니다.
//						 6. 변수의 범위가 파일 범위로 제한됩니다.(외부의 코드로 활용이 불가능 : 정적 전역 변수 : static global)

//메모리 영역
//프로그램에서는 변수, 함수 등을 저장하는 메모리 영역이 존재합니다.
//영역 별로 저장되는 데이터들은 다음과 같습니다.

//1. Code 영역
//	 --> 실행할 프로그램의 코드가 저장되는 영역, 텍스트 영역이라고도 부릅니다.
//		 CPU는 코드 영역에 저장되어있는 명령 하나하나를 가져와서 처리합니다.
//		 프로그램이 시작하고 종료하는 순간까지 메모리에 남아있게 됩니다.

//2. Data 영역
//	 --> 프로그램의 전역 변수와 정적 변수가 저장되는 영역입니다.
//		 프로그램 시작 시에 할당되면서, 프로그램이 종료되면 소멸합니다.

//3. BSS 영역
//	 --> Data 영역이 있는 변수 중에서 초기 값이 없는 전역 변수나 배열, 정적 변수가 저장되는 영역

//4. === RUTINE ===

//5. Heap 영역
//	 --> 프로그래머가 직접 메모리를 할당하고 해제하는 영역(동적 할당)
//		 C언어에서는 malloc()을 통해 할당을 작업하며, C++에서는 new를 통해 할당을 작업합니다.
//		 C언어에서는 free()를 오해 할당을 해제하며, C++에서는 delete를 통해 할당을 해제합니다.
//		 선입선출(First-In, First out : FIFO)로 먼저 들어온 데이터가 먼저 빠져나가게 되는 방식
//		 --> 낮은 주소(위)로부터 높은 주소(아래) 방향으로 데이터가 쌓이는 형태
//6. Stack 영역
//	 --> 프로그램이 자동으로 사용하는 임시 메모리 영역
//		 함수 호출 시 생성되는 지역 변수나 매개 변수가 저장되는 영역으로, 함수의 호출이 완료되면 해당 데이터는 사라집니다.
//		 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 부릅니다.
//		 Stack의 호출에는 리미트가 길려있고, 일반적인 프로그램은 특정 횟수를 넘을 경우 더 이상 호출되지 않도록 막습니다.(Stack Overflow 현상 방지)
//		 후입선출(Last-In First out : LIFO)로 나중에 들어온 데이터가 먼저 빠져나가게 되는 방식
//		 ---> 높은 주소(아래)로부터 낮은 주소(위)로 데이터가 쌓이는 형태

//오버플로(Overflow) :한정되어있는 메모리 공간이 부족해 메모리 안에 있는 데이터가 넘쳐 흐르는 현상
//문제되는 이유 : 데이터가 넘치면 상대 공간을 침범하는 일이 발생할 수 있고, 이는 데이터를 제대로 불러올 수 없는 상황까지 이어집니
//int a = 5;
//void GlobalF()
//{
//	a++;
//	cout << "(Global)" << a << endl;
//}
//void localF()
//{
//	int a = 10;
//	a++;
//	cout << "(local)" << a << endl;
//}
//void ParameterF(int a)
//{
//	a = 20;
//	a++;
//	cout << "(parameter)" << a << endl;
//}
//void staticF()
//{
//	static int a = 1;
//	a++;
//	cout << "(static)" << a << endl;
//
//	int main()
//	{
//		cout << ("main/global") << a << endl;
//		GlobalF();
//		cout << ("main/global") << a << endl;
//		int a = 10; //지역 변수 a가 있는 상태에서 지역 변수 a가 만들어진다면, 함수 내에서는 지역변수를 우선 처리됩니다.
//		GlobalF();
//		cout << ("main/local") << a << endl; //현 시점에서 main의 a는 지역변수이기 때문에 GlobalF에 의해 지역변수 a의 값이 올라도, main의 a랑은 전혀 상관 없는 값이 됩니다.
//		Parameter(a);
//		cout << ("main/local") << a << endl; //매개변수로 a의 "값"을 전달합니다. 그리고 ParameterF에서 그 값을 기바능로 매개변수 a를 할당합니다.
//											   //그 매개변수 a와 main의 지역변수 a는 서로 다른 데이터입니다.
//											   //call by refernce(참조에 의해 전달) : 매개변수를 포인터로 받거나, 참조자로 벋우묜 전달 가능
//		staticF();
//		cout << ("main /local") << a << endl;
//
//		cout << ("") << a << endl
//		//5번 역속 출력으로 확인해보는 각 함수의 특징
//		for (int = 0; i < 5; i++)
//		{
//			GlobalF();
//			localF();
//			parameterF(a)
//			StaticF();
//	return 0;
//}