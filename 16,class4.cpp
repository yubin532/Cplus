//#include <iostream>
//using namespace std;
//
////클래스 상속
////클래스와 클래스를 연결하는 행위
////객체 간에 계층적인 관계를 표현하고 싶을 경우 사용하는 설계 기법
//
////ex) Person(상위 클래스는 가장 공톹적인 부분만을 가지게 됩니다.)
////		  - Employee
////		  - Supervisor(하위 클래스로 갈수록 더 많은 작업을 진행할 수 있습니다.)
////		  - Fruit
////		  - Apple
//
////클래스 상속 만드는 방법
////class 클래스명 : 접근제한자 클래스명
////{
////
////}
//
////접근 제한자의 종류
////private : 외부 접근 금지(내부 데이터)
////public : 전체 공유(외부에서 사용할 기능)
////protected : 상속 관계까지의 연결(관계성 데이터)
//class Item
//{
//private :
//	int code;
//public :
//	string name;
//	string descripiton;
//};
//
//class Potion : public Item
//{
//public :
//	int count;
//	Potion(string name, string descripiton)
//	{
//		//this는 클래스 내부의 데이터를 확인하는 용도입니다.(자기 자신)
//		//상속을 통해 클래스를 설계하면, 기존의 클래스(부모 클래스)가 가지고 있는 값을 가지게 됩니다.
//		//단 상속의 경우 private에 대한 접근을 할 수 없습니다.
//		this->name = name;
//		this->descripiton = descripiton;
//		this->count = count;
//	}
//	void Use()
//	{
//		count--;
//		cout << "포션을 사용했습니다." << endl;
//
//		if (count <= 0)
//		{
//			delete this;
//		}
//	}
//};
//
////상속의 장점
////1. 코드의 재사용이 가능합니다.(기존의 클래스의 정보를 그대로 가져와서 사용하기 때문에
////	 비슷한 기능을 가진 새로운 클래스를 만들 때 불필요한 중복적인 내용을 만들지 않아도 됩니다.)
//
////2. 특징 서비스, API 구현에 있어서 통일된 형태의 틀로써 제공할 수 있습니다.
////	 이는 개발자들마다 각자의 스타일로 개발해 개발 혼선을 주는 문제를 해결할 수 있습니다.
////	 이는 Java나 C#의 Interface 개념과 유사합니다.
//
////인터페이스(Interface) : 공통적으로 사용되는 기능들에 대한 틀 제공(기능 구현 x)
////						  이름을 전달받은 쪽에서 자체적으로 개발하도록
////						  통일된 양식으로, 유지 보수에 효과적일 수 있습니다.
//
////3. 코드 구현 시의 구현 오류를 줄여줄 수 있습니다.
////	 (해당 기능을 상속받지 않으면 에러가 발생하도록 설계하는 방식 --> 순수 가상함수)
//
////상속의 단점
////1. 결합도가 너무 높아집니다.(하나를 고치면 관련 코드가 다 영향을 받는 경우 발생)
////2. 불칠요한 기능에 대한 상속이 발생할 수 있습니다.
////3. 상속은 두 개의 클래스를 연결하는 기능으로, 다양하게 연결되어야 하는 데이터의 표현에는 한계가 있습니다.
////4. 다이아몬드 상속 문제
////						  A,B,C,D 총 4개의 클래스가 존재합니다.
////						  이 떄 A는 B와 C를 만들었습니다.
////	이럴 경우 B와 C는 각각 D의 기능을 물려받은 상태이고.
////	그 기능을 A에게 전달할 경우 A는 B와 C의 기능 중 어떤 갓에 접근해야 하는가?라는 문제가 발생합니다.(모호성)
//
////[***] C++의 클래스 간의 관계
//
//// is A 관계
//// ~는 ~이다로 해석되는 경우를 의미합니다.
//
////ex) Pianist is a Musician.
////	  Singer is a Musician.
//
////	  Musician 클래스
////		-class Pianist : public Musician
////		-class Singer : public Musician
//
//// has A 관계
//// ~는 ~를 가지고 있다로 해석이 되는 경우를 의미합니다.
////ex) 재익이는 디지몬 카드를 가지고 있다.
//
////재익이가 디지몬 카드를 가지고 있지 않아도 문제가 발생하지 않습니다.(이 관계는)
////즉 재익 class와 디지몬 카드 class가 생성되는 시기나 소멸되는 시기가 같을 필요가 없음.
//
////상속이 안 클래스 내부에 클래스를 가지고 있는 형태로 설계합니다.
////		class 재익
////		{
////		public :
////			디지몬 카드 a;
////
////		}
//
////소유하고 있는 개체의 생성과 소멸이 종속적인 경우
//
//
////3. 컴포지션(Composition) : 구성
//// 논리적인 관계를 형성하는 경우
//// ex) 컴퓨터는 CPU를 가지고 있다.
//
////4. 연관 관계(Association)
////	 수평적인 관계에 대한 표현
////ex) 의사와 약사
////환자의 경우 의사를 만나면 약사를 만나게 된다. ( y / n )
////환자의 경우 의사를 만나면 의사를 만나게 된다. ( y / n )
//
////이 경우라면 의사와 약사가 공통적으로 할 수 있는 행위를 대상으로 기능을 구현합니다.
////ex) class Druggist {}
////	  class Doctor
////	  {
////치료를 하고 치료 결과를 기반으로 약사에게 약 처방을 요청하는 코드
////	  void Treatment(Druggist* duriggist) {}
////	  }
////	  class Doctor {}
////	  class Druggist
////	  {
////의사에게 받은 정보를 깁간으로 약 조재하는 코드
////	  void Hasty(Doctor* doctor) {}
////	  }
//
//
////5. 의존 관계(dependency)
////전달된 것을 통해 호출
////ex) 공장에서 자동차를 생성합니다.
////ex) class Die {public void motion() {} }
////	  class player
////	  {
////		public :
////			void OnDead(die die) { die.motion(0; } 
//int main()
//{
//	Potion p("빨강", "빨간색 포션이다.",1);
//	p.Use();
//
//	return 0;
//}